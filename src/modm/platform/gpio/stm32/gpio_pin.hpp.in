/*
 * Copyright (c) 2016, Fabian Greif
 * Copyright (c) 2016, Niklas Hauser
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_GPIO_PIN_HPP
#define MODM_STM32_GPIO_PIN_HPP

#include "../device.hpp"
#include "gpio_base.hpp"

namespace modm
{

namespace stm32
{

%% set port = gpio["port"] | upper
%% set reg  = "GPIO" ~ port
%% set pin  = gpio["id"]

%% for type in ["Output", "Input", ""]
	%% set name = "Gpio" ~ type ~ port ~ gpio["id"]
	%% set superclass = "Gpio" ~ (type if type != "" else "IO")

/// {{type if type != "" else "IO"}} class for Pin {{port ~ pin}}
/// @ingroup	{{partname}}_gpio
struct {{name}} : public Gpio, ::modm::{{superclass}}
{
public:
	/// Port name.
	static constexpr Port port = Port::{{port}};
	/// Pin Number.
	static constexpr uint8_t pin = {{pin}};
	/// Bitmask for registers that contain a 1bit value for every pin.
	static constexpr uint16_t mask  = 0x1 << pin;
	/// Bitmask for registers that contain a 2bit value for every pin.
	static constexpr uint32_t mask2 = 0x3 << (pin * 2);
private:
	/// Port Number.
	static constexpr uint8_t port_nr = static_cast<uint8_t>(port);
	/// Alternate Function register id. 0 for pin 0-7. 1 for pin 8-15.
	static constexpr uint8_t af_id  = pin / 8;
	/// Alternate Function offset. This depends on the af_id.
	static constexpr uint8_t af_offset =
							(af_id == 0) ? (pin * 4) : ((pin - 8) * 4);
	/// Alternate Function register mask.
	static constexpr uint32_t af_mask  = 0xf << af_offset;
	/// ExternalInterruptIRQ
%% if target["family"] == "f0"
	%% if pin|int in range(0,2)
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI0_1_IRQn;
	%% elif pin|int in range(2,4)
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_3_IRQn;
	%% elif pin|int in range(4,16)
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI4_15_IRQn;
	%% endif
%% else
	%% if pin|int in range(0,5)
		%% if target["family"] == "f3" and pin|int == 2
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI2_TSC_IRQn;
		%% else
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI{{pin}}_IRQn;
		%% endif
	%% elif pin|int in range(5,10)
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI9_5_IRQn;
	%% elif pin|int in range(10,16)
	static constexpr IRQn_Type ExternalInterruptIRQ = EXTI15_10_IRQn;
	%% endif
%% endif

	modm_always_inline static void
	setAlternateFunction(AlternateFunction alt) {
		{{reg}}->AFR[af_id] = ({{reg}}->AFR[af_id] & ~af_mask)
								| (i(alt) << af_offset);
		{{reg}}->MODER = ({{reg}}->MODER   & ~mask2)
								| (i(Mode::AlternateFunction) << (pin * 2));
	}

	/// Enable Analog Mode which is needed to use this pin as an ADC input.
	modm_always_inline static void
	setAnalogInput() {
		{{reg}}->MODER |= i(Mode::Analog) << (pin * 2);
	}

public:
	modm_always_inline static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		{{reg}}->OTYPER  = ({{reg}}->OTYPER  & ~mask)  | (i(type) << pin);
		{{reg}}->OSPEEDR = ({{reg}}->OSPEEDR & ~mask2) | (i(speed) << (pin * 2));
	}
	modm_always_inline static void configure(InputType type) {
		{{reg}}->PUPDR   = ({{reg}}->PUPDR   & ~mask2) | (i(type)  << (pin * 2));
	}
	%% for af in (gpio.af if "af" in gpio else [])
		%% if "type" in af and "name" in af and af["type"] == "analog" and target["family"] != "f0"
	/// {{name}} connects to {{af["name"]}} of {{af["peripheral"]}}
	static const ::modm::stm32::{{af["peripheral"]}}::Channel
	{{af["peripheral"]}}Channel = ::modm::stm32::{{af["peripheral"]}}::Channel::{{ af["name"] }};
		%% endif
	%% endfor
	%% if type in ["" , "Output"]
	// GpioOutput
	// start documentation inherited
	modm_always_inline static void setOutput() {
		{{reg}}->MODER   = ({{reg}}->MODER   & ~mask2) | (i(Mode::Output)<< pin * 2);
	}
	modm_always_inline static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	modm_always_inline static void set() {
		{{reg}}->BSRR = mask;
	}
	modm_always_inline static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	modm_always_inline static void reset() {
		{{reg}}->BSRR = (uint32_t(mask) << 16);
	}
	modm_always_inline static void toggle() {
		if (isSet()) {
			reset();
		} else {
			set();
		}
	}
	modm_always_inline static bool isSet() {
		return ({{reg}}->ODR & mask);
	}
	// stop documentation inherited
	modm_always_inline static void
	setOutput(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setOutput();
	}
	%% endif
	%% if type in ["", "Input"]
	// GpioInput
	// start documentation inherited
	inline static void
	setInput() {
		{{reg}}->MODER   &= ~mask2;
		// reset output type and speed
		{{reg}}->OTYPER  &= ~mask;
		{{reg}}->OSPEEDR &= ~mask2;
	}
	modm_always_inline static bool read() {
		return ({{reg}}->IDR & mask);
	}
	// end documentation inherited
	modm_always_inline static void setInput(InputType type) {
		configure(type);
		setInput();
	}
	// External Interrupts
	modm_always_inline static void
	enableExternalInterrupt()
	{
		// PA[x], x =  0 ..  3 maps to EXTICR[0]
		// PA[x], x =  4 ..  7 maps to EXTICR[1]
		// PA[x], x =  8 .. 11 maps to EXTICR[2]
		// PA[x], x = 12 .. 15 maps to EXTICR[3]
		// => bit3 and bit2 (mask 0x0c) specify the register
		// => bit1 and bit0 (mask 0x03) specify the bit position
		constexpr uint8_t index = (pin & 0x0c) >> 2;
		constexpr uint8_t bit_pos = (pin & 0x03) << 2;
		constexpr uint16_t syscfg_mask = (0x0f) << bit_pos;
		constexpr uint16_t syscfg_value = (port_nr & (0x0f)) << bit_pos;
		// Enable SYSCFG
		RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
		SYSCFG->EXTICR[index] = (SYSCFG->EXTICR[index] & ~syscfg_mask) | syscfg_value;
		EXTI->IMR |= mask;
	}
	modm_always_inline static void
	disableExternalInterrupt()
	{
		EXTI->IMR &= ~mask;
	}
	modm_always_inline static void
	enableExternalInterruptVector(const uint32_t priority)
	{
		NVIC_SetPriority(ExternalInterruptIRQ, priority);
		NVIC_EnableIRQ(ExternalInterruptIRQ);
	}
	modm_always_inline static void
	disableExternalInterruptVector()
	{
		NVIC_DisableIRQ(ExternalInterruptIRQ);
	}
	inline static void
	setInputTrigger(const InputTrigger trigger)
	{
		switch (trigger)
		{
		case InputTrigger::RisingEdge:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR &= ~(mask);
			break;
		case InputTrigger::FallingEdge:
			EXTI->RTSR &= ~(mask);
			EXTI->FTSR |=  (mask);
			break;
		case InputTrigger::BothEdges:
			EXTI->RTSR |=  (mask);
			EXTI->FTSR |=  (mask);
			break;
		}
	}
	modm_always_inline static bool
	getExternalInterruptFlag()
	{
		return (EXTI->PR & mask);
	}
	/**	\brief	Reset the interrupt flag in the interrupt routine. */
	modm_always_inline static void
	acknowledgeExternalInterruptFlag()
	{
		// Flags are cleared by writing a one to the flag position.
		EXTI->PR |= mask;
	}
	%% endif
	// GpioIO
	// start documentation inherited
	inline static Direction getDirection() {
		uint32_t mode = ({{reg}}->MODER & mask2);
		if (mode == (i(Mode::Input) << pin * 2))
			return Direction::In;
		if (mode == (i(Mode::Output) << pin * 2))
			return Direction::Out;
		return Direction::Special;
	}
	// end documentation inherited
	modm_always_inline static void
	disconnect() {
	%% if type == "Output"
		{{reg}}->MODER &= ~mask2;
		{{reg}}->OTYPER  &= ~mask;
		{{reg}}->OSPEEDR &= ~mask2;
		{{reg}}->PUPDR &= ~mask2;
	%% else
		setInput(InputType::Floating);
	%% endif
		{{reg}}->AFR[af_id] = ({{reg}}->AFR[af_id] & ~af_mask);
	}
	// connect: Hardware Gpio
	%% for af in (gpio.af|lbuild.listify if "af" in gpio else [])
		%% set use = not (	"type" not in af or
							(af["type"] == "in"     and type == "Output") or
							(af["type"] == "analog" and type == "Output") or
							(af["type"] == "out"    and type == "Input" ))
		%% if use
			%% if "name" in af and af["name"] not in ["Scl", "Sda"]
	/// Connect {{name}} as {{af["name"]}} to {{af["peripheral"]}}.
	modm_always_inline static void
	connect(TypeId::{{ af["peripheral"] }}{{ af["name"] }} /* t */) {
				%% if "type" in af and af["type"] == "analog"
		setAnalogInput();
				%% else
		setAlternateFunction(AlternateFunction::AF_{{ af["id"] }});
				%% endif
	}
			%% endif
			%% if "type" in af and af["type"]|string in ["", "out"] and type != "Input" and "name" in af and af["name"] not in ["Scl", "Sda"]
	/// Connect {{name}} as {{af["name"]}} to {{af["peripheral"]}}.
	modm_always_inline static void
	connect(TypeId::{{ af["peripheral"] }}{{ af["name"] }} /* t */,
		OutputType type, OutputSpeed speed = OutputSpeed::MHz50) {
		configure(type, speed);
		setAlternateFunction(AlternateFunction::AF_{{ af["id"] }});
	}
			%% endif
			%% if type == "" and "name" in af and af["name"] in ["Scl", "Sda"]
	/// Connect {{name}} as {{af["name"]}} to {{af["peripheral"]}}.
	inline static void
	connect(TypeId::{{ af["peripheral"] }}{{ af["name"] }} /* t */, InputType type=InputType::Floating) {
		configure(type);
					%% if af["name"] in ["Scl"]
		I2c::resetDevices< {{name}} >();
					%% endif
		configure(OutputType::OpenDrain);
		setAlternateFunction(AlternateFunction::AF_{{ af["id"] }});
	}
			%% endif
			%% if "type" in af and af["type"]|string in ["", "in"] and type != "Output" and "name" in af and af["name"] not in ["Scl", "Sda"]
	/// Connect {{name}} as {{af["name"]}} to {{af["peripheral"]}}.
	modm_always_inline static void
	connect(TypeId::{{ af["peripheral"] }}{{ af["name"] }} /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::AF_{{ af["id"] }});
	}
			%% endif
		%% endif
	%% endfor
	// connect: Software Gpio
	%% if type in ["", "Output"]
		%% for peripheral in   ["SoftwareSpiMasterMosi",
								"SoftwareSpiMasterSck"]
	/// Connect to `{{peripheral}}`.
	inline static void
	connect(::modm::TypeId::{{ peripheral }}) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
		%% endfor
	%% endif
	%% if type in [""]
		%% for peripheral in   ["SoftwareI2cMasterSda",
								"SoftwareI2cMasterScl"]
	/// Connect to `{{peripheral}}`.
	inline static void
	connect(::modm::TypeId::{{ peripheral }}, InputType type=InputType::Floating) {
		configure(type);
			%% if peripheral in ["SoftwareI2cMasterScl"]
		I2c::resetDevices< {{name}} >();
			%% endif
		set();
		setOutput(OutputType::OpenDrain);
	}
		%% endfor
	%% endif
	%% if type in ["", "Input"]
		%% for peripheral in ["SoftwareSpiMasterMiso"]
	/// Connect to `{{peripheral}}`.
	modm_always_inline static void
	connect(::modm::TypeId::{{ peripheral }}) {
		configure(InputType::Floating);
		setInput();
	}
		%% endfor
	%% endif
};

%% endfor

} // namespace stm32

} // namespace modm

#endif // MODM_STM32_GPIO_PIN_HPP
