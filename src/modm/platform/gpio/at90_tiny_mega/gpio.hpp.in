/*
 * Copyright (c) 2013-2017, Niklas Hauser
 * Copyright (c) 2017, Fabian Greif
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_AVR_GPIO_HPP
#define MODM_AVR_GPIO_HPP

//#include "../device.hpp"
#include "gpio_define.h"
#include <modm/architecture/interface/gpio.hpp>
#include <modm/architecture/interface/i2c.hpp>
#include <modm/math/utils/bit_operation.hpp>

/**
 * @ingroup 	platform
 * @defgroup	{{partname}}
 */

/**
 * @ingroup 	{{partname}}
 * @defgroup	{{partname}}_gpio GPIO
 */


namespace modm
{

namespace platform
{

/// @ingroup	{{partname}}_gpio
struct Gpio
{
	/// Each Input Pin can be configured in one of these states.
	enum class
	InputType : uint8_t
	{
		Floating,	///< The input pin is left floating
		PullUp,		///< The input pin is pulled to Vcc
	};

	/// Each External Interrupt can be configured to trigger on these conditions.
	enum class
	InputTrigger : uint8_t
	{
		LowLevel = 0b00,	///< triggers **continuously** during low level
		BothEdges = 0b01,	///< triggers on both rising and falling edge
		FallingEdge = 0b10,	///< triggers on falling edge
		RisingEdge = 0b11,	///< triggers on rising edge
	};

	/// Available ports on this device.
	enum class
	Port
	{
%% for port in ports
		{{ port | upper }},
%% endfor
	};

protected:
	/// @cond
	static constexpr uint8_t
	i(InputType config) { return static_cast<uint8_t>(config); }
	static constexpr uint8_t
	i(InputTrigger trigger) { return static_cast<uint8_t>(trigger); }
	/// @endcond
};

/**
 * Gpio OpenDrain template, which remaps the behavior of the Gpio pin to
 * simulate an open-drain output (with internal pullups if needed).
 * You must use this class for `SoftwareI2cMaster`!
 *
 * @see ::modm::SoftwareI2cMaster
 * @ingroup	{{partname}}_gpio
 * @{
 */
%% for name in ['GpioOpenDrain', 'GpioOpenDrainWithPullUp']
template< class Pin >
class {{name}} : public Pin
{
	static_assert(Pin::direction == modm::Gpio::Direction::InOut, "Pin must inherit from modm::GpioIO");
public:
	static constexpr modm::Gpio::Direction direction = modm::Gpio::Direction::Out;

public:
	modm_always_inline static void configure(Gpio::InputType /*type*/) {}
	modm_always_inline static void setInput() {}
	modm_always_inline static void setInput(Gpio::InputType /*type*/) {}
	modm_always_inline static void setOutput() {}
	modm_always_inline static void setOutput(bool status) {
		set(status);
	}
	%% if name == 'GpioOpenDrain'
	/// maps to `setInput(InputType::Floating)`
	modm_always_inline static void set() {
		Pin::setInput(Gpio::InputType::Floating);
	}
	%% else
	/// maps to `setInput(InputType::PullUp)`
	modm_always_inline static void set() {
		Pin::setInput(Gpio::InputType::PullUp);
	}
	%% endif
	/// maps to `setOutput(::modm::Gpio::Low)`
	modm_always_inline static void reset() {
		Pin::setOutput(::modm::Gpio::Low);
	}
	modm_always_inline static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}
	modm_always_inline static bool isSet() {
		return (Pin::getDirection() == modm::Gpio::Direction::In);
	}
	modm_always_inline static modm::Gpio::Direction getDirection() {
		return modm::Gpio::Direction::Out;
	}
	modm_always_inline static void
	connect(::modm::TypeId::SoftwareI2cMasterSda) {
		set();
	}
	modm_always_inline static void
	connect(::modm::TypeId::SoftwareI2cMasterScl) {
		set();
		modm::I2c::resetDevices< Pin >();
		set();
	}
};
%% endfor
/// @}

%% for gpio in gpios
	%% set port = gpio.port | upper
	%% set pin  = gpio.id

	%% for type in ["Output", "Input", "IO"]
		%% set name = "Gpio" ~ (type if type != "IO" else "") ~ port ~ pin
		%% set superclass = "Gpio" ~ type

/// {{type}} class for Pin {{port ~ pin}}
/// @ingroup	{{partname}}_gpio
struct {{name}} : public Gpio, ::modm::{{superclass}}
{
public:
	static constexpr Port port = Port::{{port}};		///< the port of this GPIO
	static constexpr uint8_t pin = {{pin}};			///< the pin  of this GPIO
	static constexpr uint8_t mask = (1 << pin);	///< the mask of this GPIO

		%% if type in ["IO", "Output"]
	modm_always_inline static void setOutput(bool status) {
		setOutput();
		set(status);
	}
	modm_always_inline static void setOutput() {
			%% if pue is defined
		PUE{{port}} &= ~mask;
			%% endif
		DDR{{port}} |= mask;
	}
	modm_always_inline static void set() {
		PORT{{port}} |= mask;
	}
	modm_always_inline static void set(bool status) {
		if (status) { set(); }
		else { reset(); }
	}
	modm_always_inline static void reset() {
		PORT{{port}} &= ~mask;
	}
	modm_always_inline static void toggle() {
			%% if notoggle is defined
		PORT{{port}} ^= mask;
			%% else
		PIN{{port}} = mask;
			%% endif
	}
	modm_always_inline static bool isSet() {
		return (PORT{{port}} & mask);
	}
		%% endif
		%% if type in ["IO", "Input"]
	modm_always_inline static void configure(InputType type) {
		if (type == InputType::PullUp) {
			%% if pue is defined
			PUE{{port}} |= mask;
			%% else
			PORT{{port}} |= mask;
			%% endif
		}
		else {
			%% if pue is defined
			PUE{{port}} &= ~mask;
			%% else
			PORT{{port}} &= ~mask;
			%% endif
		}
	}
	modm_always_inline static void
	setInput(InputType type) {
		setInput();
		configure(type);
	}
	modm_always_inline static void setInput() {
		DDR{{port}} &= ~mask;
	}
	modm_always_inline static bool read() {
		return (PIN{{port}} & mask);
	}
			%% if 'extint' in gpio
				%% set af_id = gpio.extint | int
				%% if eicra is not defined
					%% set eicra = 'EICRA'
				%% endif
	modm_always_inline static void setInputTrigger(InputTrigger trigger) {
				%% if af_id < 4
					%% if isc2 is defined and af_id == 2
		{{isc2}} = ({{isc2}} & ~(1 << ISC2)) | ((i(trigger) & 0b01) << ISC2);
					%% else
		{{eicra}} = ({{eicra}} & ~(0b11 << 2*{{af_id}})) | (i(trigger) << 2*{{af_id}});
					%% endif
				%% else
		EICRB = (EICRB & ~(0b11 << 2*{{af_id - 4}})) | (i(trigger) << 2*{{af_id - 4}});
				%% endif
	}
	modm_always_inline static void enableExternalInterrupt() {
		EIMSK |= (1 << INT{{af_id}});
	}
	modm_always_inline static void disableExternalInterrupt() {
		EIMSK &= ~(1 << INT{{af_id}});
	}
	modm_always_inline static bool getExternalInterruptFlag() {
		return (EIFR & (1 << INTF{{af_id}}));
	}
	modm_always_inline static void acknowledgeExternalInterruptFlag() {
		EIFR |= (1 << INTF{{af_id}});
	}
			%% endif
			%% if 'pcint' in gpio
				%% set af_id = gpio.pcint | int
				%#- Go home Atmel, you're drunk!
				%% set af_reg = (af_id / 8) | int
				%% if target["family"] == 'attiny'
					%% if (target["name"] in ['2313', '4313']) and af_id >= 11 and af_id <= 17
						%% set af_reg = 2
					%% elif (target["name"] in ['20', '40', '1634']) and af_id >= 12 and af_id <= 17
						%% set af_reg = 2
					%% elif (target["name"] in ['13', '25', '45', '85', '2313', '4313'])
						%% set af_reg = ""
					%% endif
				%% endif
	modm_always_inline static void enablePCInterrupt() {
		PCMSK{{af_reg}} |= (1 << PCINT{{af_id}});
		PCICR |= (1 << PCIE{{af_reg}});
	}
	modm_always_inline static void disablePCInterrupt() {
		PCMSK{{af_reg}} &= ~(1 << PCINT{{af_id}});
		if (!PCMSK{{af_reg}}) {
			PCICR &= ~(1 << PCIE{{af_reg}});
		}
	}
	modm_always_inline static bool readPCInterruptFlag() {
		return (PCIFR & (1 << PCIF{{af_reg}}));
	}
	modm_always_inline static void acknowledgePCInterruptFlag() {
		PCIFR |= (1 << PCIF{{af_reg}});
	}
			%% endif
		%% endif
		%% if type in ["IO"]
	modm_always_inline static Direction getDirection() {
		return (DDR{{port}} & mask) ? Direction::Out : Direction::In;
	}
		%% endif
	modm_always_inline static void
	disconnect() {
		%% if type == "Output"
		DDR{{port}} &= ~mask;   // manual call to setInput()
			%% if pue is defined
		PUE{{port}} &= ~mask;
			%% else
		PORT{{port}} &= ~mask;
			%% endif
		%% else
		setInput(InputType::Floating);
		%% endif
	}
		%% for af in gpio.get("af", []) | lbuild.listify
			%% if (	(af.type == 'in' and type == 'Input') or
					(af.type == 'out' and type == 'Output') or
					(af.type == 'io' or type == 'IO')	)
	/// Connect `{{port~pin}}` as `{{af.name}}` to `{{af.peripheral}}`.
	inline static void
	connect(TypeId::{{ af.peripheral }}{{ af.name }}) {
				%% if af.name == "Scl" and type == 'IO'
		modm::I2c::resetDevices< {{name}} >();
				%% endif
				%% if af.name == "Txd"
		set();
				%% endif
				%% if af.type == "out"
		setOutput();
				%% elif af.type == "in"
		setInput();
				%% endif
	}
			%% endif
		%% endfor
		%% if type in ['IO', 'Output']
			%% for peripheral in   ['SoftwareSpiMasterMosi',
									'SoftwareSpiMasterSck']
	/// Connect to `{{peripheral}}`.
	modm_always_inline static void
	connect(::modm::TypeId::{{ peripheral }}) {
		setOutput();
	}
			%% endfor
		%% endif
		%% if type in ['IO', 'Input']
			%% for peripheral in ['SoftwareSpiMasterMiso']
	/// Connect to `{{peripheral}}`.
	modm_always_inline static void
	connect(::modm::TypeId::{{ peripheral }}) {
		setInput();
	}
			%% endfor
		%% endif
};

	%% endfor
%% endfor

%# Ports
/// @cond
// forward declaration for GpioPort
template< Gpio::Port Port, uint8_t StartPin, uint8_t Width, GpioPort::DataOrder PortOrder >
class GpioPortBase;
/// @endcond

/**
 * Creates a hardware port with StartPin as LSB and with Width.
 *
 * @tparam	StartPin	a Gpio pin
 * @tparam	Width		required width of the port (up to 8)
 * @ingroup {{partname}}_gpio
 */
template< class StartPin, uint8_t Width, ::modm::GpioPort::DataOrder PortOrder = GpioPort::DataOrder::Normal >
class GpioPort : public ::modm::GpioPort, /** @cond */ public GpioPortBase< StartPin::port, StartPin::pin, Width, PortOrder > /** @endcond */
{
public:
	static constexpr uint8_t width = Width;

	static constexpr DataOrder
	getDataOrder()
	{ return PortOrder; }

	using PortType = uint8_t;

#ifdef __DOXYGEN__
	static void
	setOutput();

	static void
	setInput();

	static PortType
	read();

	static void
	write(PortType data);

	static void
	toggle();
#endif
};

/// @cond
%% for port in gpios | portRanges
template< uint8_t StartPin, uint8_t Width, ::modm::GpioPort::DataOrder PortOrder >
class GpioPortBase<Gpio::Port::{{port.name}}, StartPin, Width, PortOrder> : public Gpio
{
	static_assert(StartPin < {{port.startPin + port.width}},
			"StartPin too large, maximum {{port.startPin + port.width - 1}}.");
	static_assert(Width <= {{port.width}},
			"Width too large, maximum {{port.width}}.");
	static_assert(Width > 0,
			"Width should be at least 1.");
	static_assert(StartPin + Width <= {{port.startPin + port.width}},
			"StartPin + Width too large, maximum {{port.startPin + port.width}}.");

	static constexpr uint8_t dataMask = (1 << Width) - 1;
	static constexpr uint8_t portMask = dataMask << StartPin;

public:
	modm_always_inline static void setOutput() {
		DDR{{port.name}} |= portMask;
	}
	modm_always_inline static void setInput() {
		DDR{{port.name}} &= ~portMask;
	}
	inline static uint8_t read() {
		uint8_t data = PIN{{port.name}} & portMask;
		return (data >> StartPin);
	}
	inline static void write(uint8_t data) {
		data <<= StartPin;
		PORT{{port.name}} = (PORT{{port.name}} & ~portMask) | (data & portMask);
	}
	modm_always_inline static void toggle() {
	%% if notoggle is defined
		PORT{{port.name}} ^= portMask;
	%% else
		PIN{{port.name}} = portMask;
	%% endif
	}
};
// another specialization for DataOrder::Reversed
template< uint8_t StartPin, uint8_t Width >
class GpioPortBase<Gpio::Port::{{port.name}}, StartPin, Width, ::modm::GpioPort::DataOrder::Reversed> : public Gpio
{
	static_assert(StartPin < {{port.startPin + port.width}},
			"StartPin too large, maximum {{port.startPin + port.width - 1}}.");
	static_assert(Width <= {{port.width}},
			"Width too large, maximum {{port.width}}.");
	static_assert(Width > 0,
			"Width should be at least 1.");
	static_assert(StartPin + Width <= {{port.startPin + port.width}},
			"StartPin + Width too large, maximum {{port.startPin + port.width}}.");

	static constexpr uint8_t StartPinReversed = (4 - StartPin - Width) + 4;
	static constexpr uint8_t dataMask = (1 << Width) - 1;
	static constexpr uint8_t portMask = dataMask << StartPin;

public:
	modm_always_inline static void setOutput() {
		DDR{{port.name}} |= portMask;
	}
	modm_always_inline static void setInput() {
		DDR{{port.name}} &= ~portMask;
	}
	inline static uint8_t read() {
		uint8_t data = modm::bitReverse(uint8_t(PIN{{port.name}} & portMask));
		return (data >> StartPinReversed);
	}
	inline static void write(uint8_t data) {
		data = modm::bitReverse(uint8_t(data << StartPinReversed));
		PORT{{port.name}} = (PORT{{port.name}} & ~portMask) | (data & portMask);
	}
	modm_always_inline static void toggle() {
	%% if notoggle is defined
		PORT{{port.name}} ^= portMask;
	%% else
		PIN{{port.name}} = portMask;
	%% endif
	}
};
	%% if port.startPin == 0 and port.width == 8
template< ::modm::GpioPort::DataOrder DataOrder >
class GpioPortBase<Gpio::Port::{{port.name}}, 0, 8, DataOrder > : public Gpio
{
public:
	static constexpr uint8_t width = 8;

public:
	modm_always_inline static void setOutput() {
		DDR{{port.name}} = 0xff;
	}
	modm_always_inline static void setInput() {
		DDR{{port.name}} = 0;
	}
	modm_always_inline static uint8_t read() {
		return PIN{{port.name}};
	}
	modm_always_inline static void write(uint8_t data) {
		PORT{{port.name}} = data;
	}
	modm_always_inline static void toggle() {
		%% if notoggle is defined
		PORT{{port.name}} ^= 0xff;
		%% else
		PIN{{port.name}} = 0xff;
		%% endif
	}
};
// another specialization for DataOrder::Reversed
template<>
class GpioPortBase<Gpio::Port::{{port.name}}, 0, 8, ::modm::GpioPort::DataOrder::Reversed > : public Gpio
{
public:
	static constexpr uint8_t width = 8;

public:
	modm_always_inline static void setOutput() {
		DDR{{port.name}} = 0xff;
	}
	modm_always_inline static void setInput() {
		DDR{{port.name}} = 0;
	}
	modm_always_inline static uint8_t read() {
		return modm::bitReverse(uint8_t(PIN{{port.name}}));
	}
	modm_always_inline static void write(uint8_t data) {
		PORT{{port.name}} = modm::bitReverse(data);
	}
	modm_always_inline static void toggle() {
		%% if notoggle is defined
		PORT{{port.name}} ^= 0xff;
		%% else
		PIN{{port.name}} = 0xff;
		%% endif
	}
};
	%% endif

%% endfor
/// @endcond

}	// namespace platform

}	// namespace modm

#endif
